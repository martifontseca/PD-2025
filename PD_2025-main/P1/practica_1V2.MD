# Pr√°ctica 1: Blink con ESP32

---

## Objetivo

Esta pr√°ctica tiene como finalidad lograr el parpadeo peri√≥dico de un LED mediante el uso de un ESP32. Para ello, se utiliza la salida serie como herramienta 
de depuraci√≥n y se exploran diversas t√©cnicas: desde funciones est√°ndar de Arduino hasta el acceso directo a registros y distintos m√©todos de temporizaci√≥n.
Al final, se eval√∫a el rendimiento del microcontrolador.

---

## Microcontrolador: ESP32

### Imagen del ESP32

![ESP32](https://ae04.alicdn.com/kf/S8dee2f4cafc344e1b57ebc21ad5c11a4P.jpg?fit=600%2C600&ssl=1)

### Distribuci√≥n de pines

![Pines ESP32](https://ae04.alicdn.com/kf/S61a9f7eb6ad3487ca95acc2f410157a35.jpg?resize=966%2C574&ssl=1)

---

##  Descripci√≥n de la funcionalidad

- Iniciar pin de LED como salida
- Bucle infinito:
  - Encender LED
  - Enviar mensaje "ON" por el puerto serie
  - Esperar 500 o 1000 ms
  - Apagar LED
  - Enviar mensaje "OFF" por el puerto serie
  - Esperar 500 o 1000 ms# PRACTICA 1  :  BLINK

El objeticvo de la practica es producir el parpadeo periodico de un led. 
Se utilizara la salida serie  para depurar  el programa 

El microcontrolador que utilizaremos es el ya comentado en la introducci√≥n  **ESP32**


---

##  Implementaciones

### üü¢ 1. C√≥digo b√°sico

```cpp
#define LED_BUILTIN 2
#define DELAY 500

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  digitalWrite(LED_BUILTIN, HIGH);
  delay(DELAY);
  digitalWrite(LED_BUILTIN, LOW);
  delay(DELAY);
}


### üü¢ 2 Codigo con salida serie

#define LED_BUILTIN 2
#define DELAY_TIME 1000

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
  Serial.begin(115200);
}

void loop() {
  digitalWrite(LED_BUILTIN, HIGH);
  Serial.println("ON");
  delay(DELAY_TIME);

  digitalWrite(LED_BUILTIN, LOW);
  Serial.println("OFF");
  delay(DELAY_TIME);
}

#define LED_PIN 2

void setup() {
  pinMode(LED_PIN, OUTPUT);
  Serial.begin(115200);
}

void loop() {
  GPIO.out_w1ts = (1 << LED_PIN);
  Serial.println("ON");

  unsigned long startMillis = millis();
  while (millis() - startMillis < 500);

  GPIO.out_w1tc = (1 << LED_PIN);
  Serial.println("OFF");

  startMillis = millis();
  while (millis() - startMillis < 500);
}

![Foto de Marti Fontseca](https://github.com/martifontseca/PD_2025/blob/main/P1/Practica1/IMG_748E83AF-4ED5-4C90-9EE6-65B3522506C6.JPEG)


### üü¢ 3. Acceso directo a registros + espera activa

#define LED_PIN 2

void setup() {
  pinMode(LED_PIN, OUTPUT);
  Serial.begin(115200);
}

void loop() {
  GPIO.out_w1ts = (1 << LED_PIN);
  Serial.println("ON");

  unsigned long startMillis = millis();
  while (millis() - startMillis < 500);

  GPIO.out_w1tc = (1 << LED_PIN);
  Serial.println("OFF");

  startMillis = millis();
  while (millis() - startMillis < 500);
}


### üü¢ 4. Alternativas para medir frecuencia


#define LED_PIN 2

void setup() {
  pinMode(LED_PIN, OUTPUT);
  Serial.begin(115200);
}

void loop() {
  digitalWrite(LED_PIN, HIGH);
  Serial.println("ON");

  while(millis() % 2 == 0);

  digitalWrite(LED_PIN, LOW);
  Serial.println("OFF");

  while(millis() % 2 == 1);
}

## üü¢ Diagrama de flujo

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    setup()   ‚îÇ
‚îÇ - pinMode    ‚îÇ
‚îÇ - Serial.begin ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ   loop()  ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Encender LED‚îÇ
‚îÇ Serial "ON" ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Esperar     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Apagar LED  ‚îÇ
‚îÇ Serial "OFF"‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Esperar     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
      (loop)



 Tiempo libre del procesador

Durante las esperas activas (delay() o while()), el procesador no ejecuta otras tareas, pero tampoco realiza trabajo √∫til (bloqueo activo). Esto significa que:

    Ocupado √∫til: solo unos pocos microsegundos por ciclo.

    Tiempo "libre" (esperando): ~99.9% del tiempo.

 Conclusiones

El acceso directo a registros ofrece mayor eficiencia y permite alcanzar frecuencias de parpadeo m√°s elevadas.

Las funciones est√°ndar de Arduino mejoran la legibilidad del c√≥digo, pero introducen latencias y reducen la precisi√≥n temporal.

El uso de espera activa mediante millis() permite evitar el uso de delay(), manteniendo el control del flujo, aunque a costa de un mayor uso de CPU.

La comunicaci√≥n por puerto serie impacta negativamente en el rendimiento, reduciendo considerablemente la frecuencia m√°xima de parpadeo.

El ESP32 demuestra una alta capacidad de respuesta, siempre que no se vea bloqueado por llamadas a delay() o el uso intensivo del puerto serie.
